<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CesiumJS Globe</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.82/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.82/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #infoBox {
            position: absolute;
            background-color: rgba(42, 42, 42, 0.8);
            color: white;
            padding: 4px;
            border-radius: 4px;
            display: none;
        }
        #controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px;  /* Adjust this value as needed */
            background-color: #000;
            padding: 20px;
            border-radius: 0px;
            display: flex;
            flex-direction: row; /* Change to row to align items horizontally */
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            gap: 20px; /* Add gap between items */
        }
        #controls h2, #controls h3 {
            margin: 0;
            margin-bottom: 10px;
            color: white;
        }
        #controls .buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }
        #controls button {
            background-color: #444;
            color: white;
            border: none;
            padding: 15px;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
        }
        #controls button:hover {
            background-color: #666;
        }
        #currentTimeIndex {
            color: white;
            margin-bottom: 10px;
        }
        #progressBar {
            width: 100%;
            margin-top: 10px;
        }
        #channelSelect, #ensembleSelect {
            background-color: #444;
            color: white;
            border: none;
            padding: 10px;
            font-size: 16px;
            border-radius: 5px;
        }
        .select-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer" style="width: 100%; height: 100vh;"></div>
    <div id="infoBox"></div>
    <div id="controls">
        <div class="select-container">
            <h2>Time</h2>
            <div class="buttons">
                <button id="prevFrame">Backward</button>
                <button id="nextFrame">Forward</button>
            </div>
            <div id="currentTimeIndex">Time: 0</div>
            <input type="range" id="progressBar" min="0" max="4" value="0" step="1">
        </div>

        <div class="select-container">
            <h3>Channel</h3>
            <select id="channelSelect"></select>
        </div>

        <div class="select-container">
            <h3>Ensemble Member</h3>
            <select id="ensembleSelect"></select>
        </div>
    </div>
    <script>
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIxOWNiOWJlYy1iNjUzLTRiYWUtYTNhMC1lZjcyNjI5YjYwZWMiLCJpZCI6MjE5NDQ1LCJpYXQiOjE3MTczNDQ4NjJ9.dZJ7mbhbiw2GWOYiPPGL720XPMXvGPWfLiRsBrNT5SQ';
        var viewer = new Cesium.Viewer('cesiumContainer', {
            imageryProvider: new Cesium.IonImageryProvider({ assetId: 3 }), // Use Cesium World Terrain
        });
        var infoBox = document.getElementById('infoBox');
        var currentTimeIndex = 0;  // Initialize the current time index
        var maxTimeIndex = 4;  // Default value, will be updated dynamically
        var config_dict = {};  // To store the fetched config_dict
        var startTime = new Date();  // Default start time
        var selectedChannel = 't2m';  // Default channel
        var selectedEnsemble = 0;  // Default ensemble member

        // Debounce function to limit the rate of updates
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // Fetch the config_dict from the backend and use it to set maxTimeIndex and startTime
        fetch('/get_config')
            .then(response => response.json())
            .then(data => {
                config_dict = data;
                maxTimeIndex = config_dict.simulation_length || 4;  // Default to 4 if not found
                document.getElementById('progressBar').max = maxTimeIndex;
                startTime = new Date(config_dict.weather_event.properties.start_time);  // Treat as UTC

                // Populate channelSelect options
                const channelSelect = document.getElementById('channelSelect');
                config_dict.weather_event.domains[0].diagnostics[0].channels.forEach(channel => {
                    const option = document.createElement('option');
                    option.value = channel;
                    option.text = channel;
                    channelSelect.appendChild(option);
                });

                // Populate ensembleSelect options
                const ensembleSelect = document.getElementById('ensembleSelect');
                for (let i = 0; i < config_dict.ensemble_members; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.text = `Ensemble Member ${i + 1}`;
                    ensembleSelect.appendChild(option);
                }
            })
            .catch(error => console.error('Error fetching config:', error))
            .finally(() => {
                // All initialization code that depends on maxTimeIndex and startTime goes here

                function getColorFromTemperature(value) {
                    const minTemp = 10;
                    const maxTemp = 40;

                    value = Math.max(minTemp, Math.min(value, maxTemp));

                    const fraction = (value - minTemp) / (maxTemp - minTemp);

                    const r = Math.round(255 * fraction);
                    const g = 0;
                    const b = Math.round(255 * (1 - fraction));

                    return Cesium.Color.fromBytes(r, g, b);
                }

                function updateCurrentTimeDisplay() {
                    // Calculate the current time based on startTime and currentTimeIndex
                    let currentTime = new Date(startTime);
                    currentTime.setUTCHours(currentTime.getUTCHours() + currentTimeIndex * 6);
                    document.getElementById('currentTimeIndex').innerText = `Time: ${currentTime.toISOString()}`;
                }

                async function loadData(region, timeIndex, channel, ensemble) {
                    const response = await fetch(`/data/${region}?time=${timeIndex}&channel=${channel}&ensemble=${ensemble}`);
                    const data = await response.json();
                    const pointEntities = new Cesium.CustomDataSource('points');

                    const totalPoints = data.lons.length;
                    const chunkSize = 10000;
                    for (let i = 0; i < totalPoints; i += chunkSize) {
                        const chunkEnd = Math.min(i + chunkSize, totalPoints);
                        for (let j = i; j < chunkEnd; j++) {
                            const lon = data.lons[j];
                            const lat = data.lats[j];
                            const value = data.values[j];
                            const entity = pointEntities.entities.add({
                                position: Cesium.Cartesian3.fromDegrees(lon, lat),
                                point: {
                                    pixelSize: 8,
                                    color: getColorFromTemperature(value),
                                },
                                properties: {
                                    temperature: value.toFixed(2) + ' Â°C',
                                    longitude: lon,
                                    latitude: lat
                                }
                            });
                        }
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }

                    viewer.dataSources.add(pointEntities);

                    // Setup event handler for mouse over
                    const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
                    handler.setInputAction(function (movement) {
                        const pickedObject = viewer.scene.pick(movement.endPosition);
                        if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.id) && Cesium.defined(pickedObject.id.properties)) {
                            const longitude = pickedObject.id.properties.longitude.getValue();
                            const latitude = pickedObject.id.properties.latitude.getValue();
                            const temperature = pickedObject.id.properties.temperature.getValue();
                            infoBox.style.display = 'block';
                            infoBox.style.left = movement.endPosition.x + 10 + 'px';
                            infoBox.style.top = movement.endPosition.y + 10 + 'px';
                            infoBox.innerHTML = `Lon: ${longitude.toFixed(2)}, Lat: ${latitude.toFixed(2)}<br>${temperature}`;
                        } else {
                            infoBox.style.display = 'none';
                        }
                    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

                    // Load country borders
                    await viewer.dataSources.add(Cesium.GeoJsonDataSource.load('/geojson/countries.geo.json', {
                        stroke: Cesium.Color.YELLOW,
                        fill: Cesium.Color.TRANSPARENT,
                        strokeWidth: 2,
                        markerSymbol: '?'
                    }));
                }

                function updateTimeIndex(delta) {
                    currentTimeIndex = Math.max(0, Math.min(maxTimeIndex, currentTimeIndex + delta));
                    updateCurrentTimeDisplay();
                    loadData(region, currentTimeIndex, selectedChannel, selectedEnsemble);
                    document.getElementById('progressBar').value = currentTimeIndex;
                }

                document.getElementById('prevFrame').addEventListener('click', function() {
                    updateTimeIndex(-1);
                });

                document.getElementById('nextFrame').addEventListener('click', function() {
                    updateTimeIndex(1);
                });

                const debouncedProgressBarInput = debounce(function() {
                    currentTimeIndex = parseInt(this.value);
                    updateCurrentTimeDisplay();
                    loadData(region, currentTimeIndex, selectedChannel, selectedEnsemble);
                }, 300);

                document.getElementById('progressBar').addEventListener('input', debouncedProgressBarInput);

                document.getElementById('channelSelect').addEventListener('change', function() {
                    selectedChannel = this.value;
                    loadData(region, currentTimeIndex, selectedChannel, selectedEnsemble);
                });

                document.getElementById('ensembleSelect').addEventListener('change', function() {
                    selectedEnsemble = this.value;
                    loadData(region, currentTimeIndex, selectedChannel, selectedEnsemble);
                });

                const urlParams = new URLSearchParams(window.location.search);
                const region = urlParams.get('region') || 'global';
                loadData(region, currentTimeIndex, selectedChannel, selectedEnsemble);
                updateCurrentTimeDisplay();
            });
    </script>
</body>
</html>
